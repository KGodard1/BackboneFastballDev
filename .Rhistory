davis <- matrix(
c(1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0,
1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0,
0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0,
0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1,
0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1,
0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1,
0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0,
0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0),
nrow = 18,
ncol = 14,
byrow = TRUE,
dimnames = list(
c("EVELYN", "LAURA", "THERESA", "BRENDA", "CHARLOTTE", "FRANCES", "ELEANOR", "PEARL", "RUTH", "VERNE", "MYRNA", "KATHERINE", "SYLVIA", "NORA", "HELEN", "DOROTHY", "OLIVIA", "FLORA"),
c("6/27", "3/2", "4/12", "9/26", "2/25", "5/19", "3/15", "9/16", "4/8", "6/10", "2/23", "4/7", "11/21", "8/3")
)
)
test3 <- universal(davis, upper = 4, lower = 1, bipartite = TRUE)
library(backbone)
universal_bb <- universal(davis, upper = function(x)mean(x)+sd(x), lower=function(x)mean(x)-sd(x), bipartite = TRUE)
class(NULL)
universal <- function(B,
upper = 1,
lower = NULL,
bipartite = FALSE){
if ((class(upper)!="function") & (class(upper)!="numeric")) {stop("upper must be either function or numeric")}
if ((class(lower)!="function") & (class(lower)!="numeric") & (class(lower)!="NULL")) {stop("lower must be either function or numeric")}
if (bipartite == TRUE){
P <- B%*%t(B)
} else {
P <- B
}
#Set threshold values
if (class(upper) == "function"){
ut <- upper(P)
}
else{ut <- upper}
if (class(lower) == "function"){
lt <- lower(P)
}
else{lt <- lower}
#Create backbone matrix
backbone <- matrix(0, nrow(P), ncol(P))
negative <- (P<=lt)+0
positive <- (P>=ut)+0
if (length(lower) > 0){
backbone <- backbone - negative
}
backbone <- backbone + positive
diag(backbone) <- 0
return(backbone)
}
library(backbone)
?op
?layout_
library(backbone)
G <- davis%*%t(davis) #projected davis dataset, a weighted graph
universal_bb <- universal(G, upper = 0)
graph <- igraph::graph_from_adjacency_matrix(universal_bb, mode = "undirected")
plot(graph)
library(backbone)
library(backbone)
library(backbone)
library(backbone)
?backbone
browseVignettes("backbone")
library(backbone)
devtools::build()
library(backbone)
packageVersion("backbone")
install.packages("C:/Users/Rachel/Dropbox/MSU/Research/2019 Backbone/Backbone Package/backbone_1.0.4.tar.gz", repos = NULL, type = "source")
library(backbone)
packageVersion("backbone")
browseVignettes(backbone)
browseVignettes("backbone")
vignette("backbone_introduction", package = "backbone")
?backbone
library(backbone)
?sdsm
library(backbone)
library(backbone)
?sdsm
?fdsm
library(backbone)
library(backbone)
?fdsm
library(backbone)
?fdsm
library(backbone)
library(backbone)
?fdsm
library(backbone)
?fdsm
library(backbone)
?sdsm
sdsm_props <- sdsm(davis, trials = 100,dyad = c("EVELYN", "CHARLOTTE" ))
library(backbone)
library(backbone)
?backbone
??backbone
library(backbone)
RShowDoc(backbone)
RShowDoc("backbone")
help(package = "backbone")
help(package = "stats")
help(package = "igraph")
help(package = "disparityfilter")
help(package = "circlize")
?circlize
help(package = "CVXR")
library(backbone)
help(package = "backbone")
devtools::build
devtools::build()
install.packages("C:/Users/Rachel/Dropbox/MSU/Research/2019 Backbone/Backbone Package/backbone_1.0.0.tar.gz", repos = NULL, type = "source")
library(backbone)
version(backbone)
package_version(backbone)
package_version("backbone")
help("backbone")
library(backbone)
devtools::build()
check(cleanup = FALSE,manual = TRUE,path = getwd())
devtools::check(cleanup = FALSE, manual = TRUE, path = getwd())
devtools::build_manual(path=getwd())
Sys.getenv("PATH")
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"C:/Program Files/MiKTeX 2.9/miktex/bin/x64/",sep=";"))
devtools::build_manual(path=getwd())
devtools::check(manual=TRUE)
Sys.which("pdflatex")
Sys.getenv("PATH")
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"/usr/texbin",sep=":"))
Sys.which("pdflatex")
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"C:/Program Files/MiKTeX 2.9/miktex/bin/x64/",sep=";"))
Sys.which("pdflatex")
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"C:/Program Files/MiKTeX 2.9/miktex/bin/x64/",sep=":"))
Sys.which("pdflatex")
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"C:/Program Files/MiKTeX 2.9/miktex/bin/x64/",sep=":"))
Sys.which("pdflatex")
Sys.getenv("PATH")
Sys.unsetenv()
Sys.unsetenv(x)
Sys.unsetenv("PATH")
Sys.getenv("PATH")
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"C:/Program Files/MiKTeX 2.9/miktex/bin/x64/",sep=";"))
Sys.getenv("PATH")
Sys.unsetenv("PATH")
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"C:/Program Files/MiKTeX 2.9/miktex/bin/x64/"))
Sys.getenv("PATH")
Sys.which("pdflatex")
Sys.getenv("PATH")
Sys.which("pdflatex")
Sys.getenv("PATH")
Sys.setenv("PATH" = "C:/Program Files/MikTeX 2.9/miktex/bin/x64")
Sys.getenv("PATH")
devtools::check("backbone")
devtools::check(cleanup = FALSE,manual = TRUE,path = getwd())
library(backbone)
devtools::build_manual(pgk = "backbone")
devtools::build_manual(pkg = "backbone")
devtools::build_manual()
Sys.which("pdflatex")
Sys.setenv("PATH" = "C:/Program Files/MikTeX 2.9/miktex/bin/x64")
Sys.getenv("PATH")
Sys.which("pdflatex")
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
H
devtools::check()
Sys.getenv("RSTUDIO_PANDOC")
Sys.setenv(RSTUDIO_PANDOC = Sys.getenv("RSTUDIO_PANDOC"))
devtools::check()
?rmarkdown::pandoc_available
pandoc_available()
library(rmarkdown)
pandoc_available()
Sys.getenv("RSTUDIO_PANDOC")
Sys.setenv(RSTUDIO_PANDOC = 'C:/Users/Rachel/Anaconda3/envs/rstudio/Library/Scripts/pandoc')
pandoc_available()
library(backbone)
devtools::build_manual()
Sys.which("pdflatex")
library(backbone)
devtools::build_manual()
Sys.getenv("pdflatex")
tinytex::install_tinytex()
Sys.getenv("pdflatex")
devtools::build_manual()
library(tinytex)
devtools::build_manual()
Sys.which("pdflatex")
Sys.getenv("PATH")
devtools::check()
devtools::check()
devtools::build_manual()
library(backbone)
library(backbone)
devtools::build_manual()
Sys.getenv("pdflatex")
Sys.getenv("pdflatex")
devtools::build_manual()
help(backbone)
browseVignettes("backbone")
Sys.setenv(PATH = paste(Sys.getenv("PATH"), "C:/Program Files/MiKTeX 2.9/miktex/bin/x64", sep = ":"))
Sys.getenv("pdflatex")
devtools::build_manual()
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"C:/Program Files/MiKTeX 2.9/miktex/bin/x64/",sep=";"))
Sys.getenv("PATH")
Sys.getenv("pdflatex")
Sys.which("pdflatex")
devtools::build_manual()
library(backbone)
?fdsm
devtools::build_manual()
devtools::build_manual()
library(tidyverse)
install.packages("tidyverse")
install.packages("tidyverse")
check_man <- function(){
man_files <- list.files("man", full.names = T)
dir.create("man_backup", showWarnings = F)
file.copy(man_files, "man_backup")
unlink(man_files)
n_man_file <- list.files("man_backup", full.names = T)
tp <- tempdir()
for_a_man <- function(mn){
cat("Checking: ", basename(mn))
file.copy(mn, "man")
devtools::build_manual(path = tp)
chk <- length(list.files(tp, ".pdf$")) > 0
d0 <- tibble(man_file = basename(mn), test = chk)
unlink(list.files(tp, ".pdf$", full.names = T))
unlink(list.files("man", full.names = T))
cat(" ... Done!", ifelse(chk, "ok","issues"),"\n")
d0
}
all_checks <- n_man_file %>% map_df(for_a_man)
file.copy(n_man_file, "man")
unlink(tp, recursive = T)
unlink("man_backup", recursive = T)
all_checks
}
check_man()
all_checks <- n_man_file %>% map_df(for_a_man)
library(tidyverse)
all_checks <- n_man_file %>% map_df(for_a_man)
check_man <- function(){
man_files <- list.files("man", full.names = T)
dir.create("man_backup", showWarnings = F)
file.copy(man_files, "man_backup")
unlink(man_files)
n_man_file <- list.files("man_backup", full.names = T)
tp <- tempdir()
for_a_man <- function(mn){
cat("Checking: ", basename(mn))
file.copy(mn, "man")
devtools::build_manual(path = tp)
chk <- length(list.files(tp, ".pdf$")) > 0
d0 <- tibble(man_file = basename(mn), test = chk)
unlink(list.files(tp, ".pdf$", full.names = T))
unlink(list.files("man", full.names = T))
cat(" ... Done!", ifelse(chk, "ok","issues"),"\n")
d0
}
all_checks <- n_man_file %>% map_df(for_a_man)
file.copy(n_man_file, "man")
unlink(tp, recursive = T)
unlink("man_backup", recursive = T)
all_checks
}
check_man()
check_man()
library(backbone)
?davis
check_man()
check_man()
check_man()
library(backbone)
check_man()
check_man()
library(backbone)
check_man()
library(backbone)
library(tidyverse)
check_man <- function(){
man_files <- list.files("man", full.names = T)
dir.create("man_backup", showWarnings = F)
file.copy(man_files, "man_backup")
unlink(man_files)
n_man_file <- list.files("man_backup", full.names = T)
tp <- tempdir()
for_a_man <- function(mn){
cat("Checking: ", basename(mn))
file.copy(mn, "man")
devtools::build_manual(path = tp)
chk <- length(list.files(tp, ".pdf$")) > 0
d0 <- tibble(man_file = basename(mn), test = chk)
unlink(list.files(tp, ".pdf$", full.names = T))
unlink(list.files("man", full.names = T))
cat(" ... Done!", ifelse(chk, "ok","issues"),"\n")
d0
}
all_checks <- n_man_file %>% map_df(for_a_man)
file.copy(n_man_file, "man")
unlink(tp, recursive = T)
unlink("man_backup", recursive = T)
all_checks
}
check_man()
check_man()
library(backbone)
check_man()
?davis
??davis
davis
devtools::build_manual()
library(backbone)
devtools::build_manual()
library(backbone)
devtools::build_manual()
?davis
library(backbone)
devtools::build_manual()
?davis
library(backbone)
?davis
devtools::build_manual()
devtools::build_manual()
library(backbone)
devtools::build_manual()
devtools::build_manual()
library(backbone)
devtools::build_manual()
devtools::build_manual()
devtools::build()
devtools::check()
devtools::build()
devtools::build()
help(package = 'backbone')
devtools::install_github("metacran/cranlogs")
library(cranlogs)
library(devtools)
file.exists("~/.ssh/id_rsa.pub")
file.exists("~/.ssh/id_rsa.pub")
Sys.which('git')
library(backbone)
browseVignettes("backbone")
devtools::build()
browseVignettes("backbone")
install.packages("backbone")
browseVignettes("backbone")
file.exists("~/.ssh/id_rsa.pub")
file.exists("~/.ssh/id_rsa.pub")
file.exists("~/.ssh/id_rsa.pub")
library(backbone)
file.exists("~/.ssh/id_rsa.pub")
P <- davis%*%t(davis)
library(backbone)
install.packages("Rtools")
library(backbone)
install.packages("devtools")
library(devtools)
library(backbone)
install.packages(Rtools)
install.packages("Rtools")
library(backbone)
install.packages("knitr")
install.packages("igraph")
install.packages("rmarkdown")
library(backbone)
P <- davis%*%t(davis)
indices <- which(P == 0)
indicies
indices
P[indices]
P[[indices]]
dim(davis)[2]
davis
P
fdsm_props <- fdsm(davis, trials = 100, sparse = TRUE, dyad=c("OLIVIA","LAURA"))
bb <- backbone.extract(fdsm_props$positive)
bb
View(bb)
fdsm <- function(B,
trials = 1000,
sparse = TRUE,
dyad = NULL,
progress = FALSE){
#Argument Checks
if ((sparse!="TRUE") & (sparse!="FALSE")) {stop("sparse must be either TRUE or FALSE")}
if ((trials < 1) | (trials%%1!=0)) {stop("trials must be a positive integer")}
if (class(B)!="matrix") {stop("input bipartite data must be a matrix")}
#Project to one-mode data
if (sparse=="TRUE") {
B <- Matrix::Matrix(B,sparse=T)
P<-B%*%Matrix::t(B)
}
if (sparse=="FALSE") {P<-B%*%t(B)}
#Create Positive and Negative Matrices to hold backbone
Positive <- matrix(0, nrow(P), ncol(P))
Negative <- matrix(0, nrow(P), ncol(P))
#Dyad save
edge_weights <- numeric(trials)
if (length(dyad) > 0){
if (class(dyad[1]) != "numeric"){
vec <- match(c(dyad[1], dyad[2]), rownames(B))
}
else{
vec <- dyad
}
}
#Build null models
for (i in 1:trials){
#Algorithm credit to: Strona, G., Nappo, D., Boccacci, F., Fattorini, S., San-Miguel-Ayanz, J. (2014). A fast and unbiased procedure to randomize ecological binary matrices with fixed row and column totals. Nature Communications, 5, 4114
#Use curveball to create an FDSM Bstar
m <- B
RC=dim(m) #matrix dimensions
R=RC[1]   #number of rows
C=RC[2]   #number of columns
hp=list() #create a list
for (row in 1:dim(m)[1]) {hp[[row]]=(which(m[row,]==1))}
l_hp=length(hp)
for (rep in 1:(5*l_hp)){
AB=sample(1:l_hp,2)
a=hp[[AB[1]]]
b=hp[[AB[2]]]
ab=intersect(a,b)
l_ab=length(ab)
l_a=length(a)
l_b=length(b)
if ((l_ab %in% c(l_a,l_b))==F){
tot=setdiff(c(a,b),ab)
l_tot=length(tot)
tot=sample(tot, l_tot, replace = FALSE, prob = NULL)
L=l_a-l_ab
hp[[AB[1]]] = c(ab,tot[1:L])
hp[[AB[2]]] = c(ab,tot[(L+1):l_tot])}
}
rm=matrix(0,R,C)
for (row in 1:R){rm[row,hp[[row]]]=1}
Bstar <- rm
if (sparse=="TRUE") {Bstar <- Matrix::Matrix(Bstar,sparse=T)}
#Construct Pstar from Bstar
if (sparse=="TRUE") {Pstar<-Bstar%*%Matrix::t(Bstar)}
if (sparse=="FALSE") {Pstar<-Bstar%*%t(Bstar)}
#Start estimation timer; print message
if (i == 1) {
start.time <- Sys.time()
message("Finding the Backbone using Curveball FDSM")
}
#Check whether Pstar edge is larger/smaller than P edge
Positive <- Positive + (Pstar > P)+0
Negative <- Negative + (Pstar < P)+0
#Save Dyad of P
if (length(dyad) > 0){
edge_weights[i] <- Pstar[vec[1], vec[2]]
}
#Report estimated running time, update progress bar
if (i==10){
end.time <- Sys.time()
est = (round(difftime(end.time, start.time, units = "auto"), 2) * (trials/10))
message("Estimated time to complete is ", est, " " , units(est))
if (progress == "TRUE"){
pb <- utils::txtProgressBar(min = 0, max = trials, style = 3)
}
}
if ((progress == "TRUE") & (i>=10)) {utils::setTxtProgressBar(pb, i)}
} #end for loop
if (progress == "TRUE"){close(pb)}
#Proporition of greater than expected and less than expected
Positive <- (Positive/trials)
Negative <- (Negative/trials)
### New Addition ###
#Find which projected values = 0
indices <- which(P == 0)
#switch those indices in positive and negative to 1, so that they won't trip alpha values
Positive[indices] <- 1 #value cannot be 1 in bb
#Same with projected values = dim(B[2])
indices <- which(P == dim(B)[2])
Negative[indices] <- 1 #value cannot be -1 in bb
### End Addition ###
rownames(Positive) <- rownames(B)
colnames(Positive) <- rownames(B)
rownames(Negative) <- rownames(B)
colnames(Negative) <- rownames(B)
if (length(dyad) > 0){
return(list(positive = Positive, negative = Negative, dyad_values = edge_weights))
}
else {
return(list(positive = Positive, negative = Negative))
}
} #end fdsm function
fdsm_props <- fdsm(davis, trials = 100, sparse = TRUE, dyad=c("OLIVIA","LAURA"))
fdsm_props$dyad_values
bb <- backbone.extract(fdsm_props$positive, fdsm_probs$negative)
bb <- backbone.extract(fdsm_props$positive, fdsm_props$negative)
bb["OLIVIA", "LAURA"]
bb <- backbone.extract(fdsm_props$positive)
bb["OLIVIA", "LAURA"]
